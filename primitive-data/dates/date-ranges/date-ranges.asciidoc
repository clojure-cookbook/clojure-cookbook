[au="Ryan Neufeld"]
=== Generating Ranges of Dates and Times

==== Problem

You need to generate a lazy sequence covering a range of dates and/or times.

==== Solution

This problem has no _easy_ solution in Java, nor does it have one in
Clojure - third-party libraries included. It is possible to use
https://github.com/clj-time/clj-time[clj-time] to get close, though.
By composing clj-time's +Interval+ and +periodic-seq+ functionality
you can create a function +time-range+ that mimics +range+'s
capabilities but for DateTimes.

[source,clojure]
----
(require '[clj-time.core :as time])
(require '[clj-time.periodic :as time-period])

(defn time-range
  "Return a lazy sequence of DateTime's from start to end, incremented
  by 'step' units of time."
  [start end step]
  (let [inf-range (time-period/periodic-seq start step) <1>
        below-end? (fn [t] (time/within? (time/interval start end) <2>
                                         t))]
    (take-while below-end? inf-range))) <3>
----

This is how you can use the +time-range+ function:

[source,clojure]
----
(def months-of-the-year (time-range (time/date-time 2012 01)
                                    (time/date-time 2013 01)
                                    (time/months 1)))

;; months-of-the-year is an unrealized lazy sequence
(realized? months-of-the-year)
;; -> true

(count months-of-the-year)
;; -> 12
----

==== Discussion

While there is no ready-made, out-of-the-box +time-range+ solution in
Clojure, it is trivial to construct such a function with purely lazy
semantics.

The basis for our lazy +time-range+ function is a ray of values from +start+ to
infinite. This ray is generated by using +periodic-seq+ with +start+ and +step+
<1> -- values indicating at which point in time the range starts and how much
later in time each step, respectively. +periodic-seq+ returns an infinite lazy
sequence of values beginning at +start+ - each subsequent value is one +step+
later than the last.

The next thing required is a _lazy_ way to *stop* acquiring values
when +end+ is reached. The +below-end?+ function created in +let+ uses
+clj-time.core/interval+ to construct an interval from +start+ to
+end+ and +clj-time.core/within?+ to test if a time +t+ falls within that
interval <2>. This function is passed as the predicate for
+take-while+ <3>, a function that returns a lazy sequence that
terminates once +below-end?+ fails. All together, +time-range+ returns a lazy
sequence of DateTime objects that stretches from a start time to an end time,
stepped appropriately by the provided +step+ value.

Imagine trying to build something similar in a language
without first-class laziness.
