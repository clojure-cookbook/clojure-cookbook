=== Finding values which cause failure

[role="byline"]
by Luke VanderHart

==== Problem

You want to specify properties of a function that should hold true for
all inputs, and find input values that violate those properties.

==== Solution

Use simple-check, a property specification library for Clojure that
is capable of "shrinking" the input case to find the minimal failing
input.

Start by adding a project dependency to the simple-check library:
+[reiddraper/simple-check "0.5.3"]+.

Then, find a function to test. This example uses a contrived function
which calculates the sum of the reciprocals of a sequence of numbers:

[source,clj]
----
(defn reciprocal-sum [s]
  (reduce + (map (partial / 1) s)))
----

The test code itself:

[source,clj]
----
(ns myapp.test
  (:require [simple-check.core :as sc]
            [simple-check.generators :as gen]
            [simple-check.properties :as prop]))

(def seq-of-numbers (gen/one-of [(gen/vector gen/int)
                                 (gen/list gen/int)]))

(def reciprocal-sum-check
  (prop/for-all [s seq-of-numbers]
    (number? (reciprocal-sum s))))
----

+seq-of-numbers+ is a data generator composed of primitive
generators found in the +simple-check.generators+ namespaces.

[NOTE]
====

Unlike test.generative, simple-check generators are more complicated
than a single function which returns a value. Instead, they are a data
structure that not only defines how random values are sampled, but how
they converge on the "simplest" possible failing case.

A full discussion of creating custom simple-check generators (other
than simple compositions of primitive generators) is beyond the scope
of this recipe, but full documentation is available on the
simple-check https://github.com/reiddraper/simple-check[GitHub page].
====

The actual test is defined using the +simple-check.properties/for-all+
macro, which emits a property definition. It takes a binding form
(similar to +let+ or +for+) which specifies the possible values to
bind to one or more symbols, and a body. The body is what actually
specifies the properties that must hold, and must return true if and
only if the test passes for a particular set of values.

To run the test, invoke the +simple-check.core/quick-check+ function,
passing it the defined property.

[source,clj]
----
(sc/quick-check 100 reciprocal-sum-check)
----

+quick-check takes the number of samples to execute, and the property
definition to execute. The body of the property definition will be
sampled repeatedly, with randomized values bound to the symbols
specified in the binding form.

As you may have already observed, the +reciprocal-sum+ function has a
problem: it will throw a "divide by zero" error if a zero is present
in the input sequence. The +quick-check+ function returns a data
structure showcasing the problem.

[source,clj]
----
{:result
 #<ArithmeticException java.lang.ArithmeticException: Divide by zero>,
 :failing-size 8,
 :num-tests 9,
 :fail [(5 0 0 -8 1 -2)],
 :shrunk
 {:total-nodes-visited 10,
  :depth 5,
  :result
  #<ArithmeticException java.lang.ArithmeticException: Divide by zero>,
  :smallest [(0)]}}
----

Fix the function by eliminating zero values:

[source,clj]
----
(defn reciprocal-sum [s]
  (reduce + (map (partial / 1)
                 (filter (complement zero?) s))))
----

Re-running the test now indicates success.

[source,clj]
----
{:result true, :num-tests 100, :seed 1384622907885}
----

==== Discussion

simple-check has the very useful property of not only returning
_a_ failing sample input to a test, but returning the _minimal_
failing sample. In the example program above, for instance, any time a
zero occurs in the input sequence it causes an error. However, merely
from looking at the sequence +(5 0 0 -8 1 -2)+ it might not be
4apparent that zeros are the problem. Not knowing anything else about
the function under test, the problem might be, for example, the
negative numbers, or the value +5+. simple-check returns not just any
arbitratry failing input, but _the_ specific input that will
consistently cause the program to fail. As useful as it is to know
that there is an input that will provoke failure, it's even more
useful to know the specific problematic value. And, the larger and
more complex the inputs to the function, the more useful it is to be
able to reduce the failing case.

.Sidebar test.generative and simple-check
****
You may have observed that test.generative and simple-check cover a
lot of the same ground. They both generate a randomized distribution
of inputs, and they both specify "success" conditions in terms of
properties or qualities that must hold across all inputs and outputs
rather than specific examples.

However, there are a few key differences. simple-check minimizes the
failing input before returning; test.generative bails the first time
it sees a failure. However, the data generators of test.generative are
simple functions, without any additionally specified behavior, which
makes them much more flexible and easy to extend.

test.generative also provides the ability to specify not only how many
iterations of the test to run, but how long to test for, running as
many tests as it can fit into the allotted timeframe across multiple threads.

Ultimately, both are valuable approaches that you should seriously
consider when you want to really, thoroughly test something. The
decision between them should be mediated by your own specific needs;
how large or complicated the inputs are, how much control you want
over runtime, and how likely you are to need to extend the set of
generated primitives.
****



