[[sec_red_black_part_i]]
=== Implementing custom data structures: Red-Black Trees - Part I
[role="byline"]
by Leonardo Borges

==== Problem

You want to implement a data structure in Clojure with very specific
performance characteristics.

For example, you need fast, efficient in-memory searches across a
large, random and ever-changing data set.

==== Solution

After identifying that Clojure's core data structures are not
appropriate for your domain, your first step is to determine what data
structure *is* appropriate.

For the purpose of this recipe, assume you are trying to choose and
implement a data structure appropriate for fast in-memory search of a
large, random and ever-changing data set. At first, a binary search
tree (BST) seems like a good solution. A BST is most efficient over a
sorted data set, however. Adding and removing large amounts of data
may unbalance a BST and degenerate its performance to that of a linked
list.

Red-Black trees (RBT) are similar to BSTs, but are self-balancing. This
would be an appropriate data structure for the data set in question.

The next step is to implement the data structure itself. The
implementation of RBTs relies on pattern matching. Use
https://github.com/clojure/core.match[core.match] to simplify the
implementation of a RBT.

Add `[org.clojure/core.match "0.2.0-rc5"]` to your project's
dependencies, or start a REPL with lein-try:

[source,console]
----
lein try core.match
----

Now implement the core of RBT, the +balance+ and +insert-val+
functions:

[source,clojure]
----
(require '[clojure.core.match :refer [match]])

(defn- balance
  "Ensures the given sub-tree stays balanced by rearranging black nodes
  which have at least one red child and one red grandchild"
  [tree]
  (match [tree]
         [(:or [:black [:red [:red a x b] y c] z d]
               [:black [:red a x [:red b y c]] z d]
               [:black a x [:red [:red b y c] z d]]
               [:black a x [:red b y [:red c z d]]])] [:red [:black a x b]
                                                            y
                                                            [:black c z d]]
               :else tree))

(defn- insert-val
  "Inserts x in tree.
  Returns a node with x and no children if tree is nil.

  Returned tree is balanced. See also `balance`"
  [tree x]
  (let [ins (fn ins [tree]
              (match tree
                     nil [:red nil x nil]
                     [color a y b] (cond
                                    (< x y) (balance [color (ins a) y b])
                                    (> x y) (balance [color a y (ins b)])
                                    :else tree)))
        [_ a y b] (ins tree)]
    [:black a y b]))
----

// New ^^^^, old vvvv

Then, define a couple of helper functions which will make dealing with
our Red-Black tree easier:

[source,clojure]
----
(defn- is-member?
  "Returns true if tree contains x"
  [tree x]
  (match tree
         nil false
         [_ a y b] (cond
                    (< x y) (recur a x)
                    (> x y) (recur b x)
                    :else true)))

(defn- find-val
  "Finds value x in tree"
  [tree x]
  (match tree
         nil nil
         [_ a y b] (cond
                    (< x y) (recur a x)
                    (> x y) (recur b x)
                    :else x)))
----

Next, we can take it for a whirl:

[source,clojure]
----
;; Load some data
(def rb-tree (reduce insert-val nil (range 10)))

;; Find specific values
(find-val rb-tree 9)   ; 9
(find-val rb-tree 100) ; nil
----

==== Discussions

The 
// New ^^^^, old vvvv

For anyone who has ever had to implement a Red-Black Tree - or at
least attended a class in Computer Science where the algorithm was
taught - the implementation of +balance+ might seem extremely short.
The reason for this is threefold:

* Our Red-Black Tree is persistent: operations on it, such as insert
  and balance, are not destructive
* +balance+ uses https://github.com/clojure/core.match[core.match], a
  pattern matching library for Clojure.
* We represent nodes as vectors

The later two points are related as you'll see below.

https://github.com/clojure/core.match[core.match] allows us to match
on the shape and values of a data structure as well as perform
structural binding at the same time. For example, the code below tries
to match +a-vector+ against two clauses:

[source,clojure]
----
(def a-vector [1 2 3])
(match a-vector
       [_ y] (str "Got y: " y)
       [_ _ z] (str "Got z: " z))
;; "Got z: 3"
----

The first matches a two-element array whereas the second matches a
3-element array. Given +a-vector+ has exactly three elements, it
matches the second clause. But not only that, we also give the third
element a binding, +z+, which we can use in the code handling that
specific clause.

This is why we represent nodes as vectors - it makes pattern matching
them a breeze:

[source,clojure]
----
(def rb-node [:red nil 3 [:black nil 4 nil]])
(match rb-node
       [:red left value right]   (str "Red node with value: " value)
       [:black left value right] (str "Black node with value: " value))
;; "Red node with value: 3"
----

All other functions simply take advantage of all the work +balance+ is
doing and become a lot simpler.

*A note on performance*

One might suggest a simpler way to achieve this goal is to first load
all data into a vector, sort it and use Java's +binarySearch+ method
to search across the dataset. This would be the case had the problem
statement not mentioned that the dataset can change between searches.

Instead of making any claims, I'll show how both solutions perform in
a little benchmark.

The benchmark adds items to the existing tree - or vector - and
attempts to find an element. The benchmark is executed three times in
order to give us a sense of the average time elapsed.

First, our Red-Black Tree Implementation:

[source,clojure]
----
(def rbtree (reduce insert-val nil (range 10)))
(dotimes [_ 3]
  (time
   (dotimes [_ 400]
     (-> rbtree
         (insert-val 500)
         (insert-val 550)
         (insert-val 200)
         (find-val 200)))))

;; "Elapsed time: 29.552 msecs"
;; "Elapsed time: 22.656 msecs"
;; "Elapsed time: 22.577 msecs"
----

Next, the solution using Java's +binarySearch+:

[source,clojure]
----
(def vector (vec (range 1000 5000)))
(dotimes [_ 3]
  (time
   (dotimes [_ 400]
     (let [coll (-> vector
                    (conj 500)
                    (conj 550)
                    (conj 200)
                    sort)]
       (nth coll (java.util.Collections/binarySearch coll 200 compare))))))

;; "Elapsed time: 351.09 msecs"
;; "Elapsed time: 328.122 msecs"
;; "Elapsed time: 361.52 msecs"
----

This is quite a difference. The second solution suffers from the
nature of the data changing between each search, requiring us to sort
the vector each time in order for the binary search to work.

Our Red-Black Tree on the other hand keeps itself balanced as each
item is inserted so the cost of inserting new elements in negligible.

One limitation of our data structure at the moment is that we can't
use core clojure functions such as +map+ and +filter+.

In <<sec_red_black_part_ii>> we'll address this very issue.

==== See Also
* <<sec_red_black_part_ii>>
* See http://en.wikipedia.org/wiki/Red%E2%80%93black_tree[Red-Black
  Trees on Wikipedia] for a more traditional take on this interesting
  data structure.
* For the functional approach used in this recipe, the book
  http://www.amazon.com/Purely-Functional-Structures-Chris-Okasaki/dp/0521663504/ref=sr_1_1?ie=UTF8&qid=1376914321&sr=8-1&keywords=purely+functional+data+structures[Purely
  Functional Data Structures] is an excellent source. It deals with
  how to efficiently implement data structures in a functional
  setting. The author chose to use ML and Haskell but its concepts are
  transferable to Clojure, as demonstrated above.
