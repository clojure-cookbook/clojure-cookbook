=== Combining Maps

===== Problem

You have two or more maps you wish to combine to produce a single map.

===== Solution

Use +merge+ to combine two maps when they share no keys.

[source,clojure]
----
(def arizona-bird-counts {:cactus-wren 8 :phainopepla 4 :mourning-dove 20})
(def florida-bird-counts {:gull 20 :anhinga 8 :pelican 14 :egret 4})

(merge florida-bird-counts arizona-bird-counts)
;; -> {:mourning-dove 20, :pelican 14, :phainopepla 4, :cactus-wren 8,
;;     :egret 4, :gull 20, :anhinga 8}
----

When mappings for the same key exist in more than one map, the latter
mapping is used in the result.

[source,clojure]
----
(def vote-count-AM   {"W.H.Harrison" 82, "J.K.Polk" 54, "M.Fillmore" 12, "U.S.Grant" 727})
(def vote-count-PM   {"W.H.Harrison" 2360, "J.K.Polk" 554, "M.Fillmore" 1312})

(merge vote-count-AM vote-count-PM)
;; -> {"J.K.Polk" 554, "U.S.Grant" 727, "M.Fillmore" 1312, "W.H.Harrison" 2360}
----

Use +merge-with+ when you want to build up a resulting value for keys
that exist in more than one map.

[source,clojure]
----
(def florida-bird-counts {:gull 20 :anhinga 8 :pelican 14 :egret 4 })
(def california-bird-counts {:gull 12 :pelican 4 :egret 11 :jay 3})

(merge-with + california-bird-counts florida-bird-counts)
;; -> {:pelican 18, :egret 15, :gull 32, :jay 3, :anhinga 8}
----

[source,clojure]
----
(def first-names {1 "Joe", 2 "Mary", 3 "Jane", 5 "Carl"})
(def last-names  {1 "Jones", 5 "Case", 2 "Hart", 3 "Smith"})
(def people-ids  {1 100 2 202 3 333 5 500})

(merge-with str first-names people-ids)
;; -> {1 "Joe100", 2 "Mary202", 3 "Jane333", 5 "Carl500"}

(merge-with #(str %1 ", " %2) last-names first-names)
;; -> {1 "Jones, Joe", 2 "Hart, Mary", 3 "Smith, Jane", 5 "Case, Carl"}
----

With careful choice of map value types, +merge-with+ provides some
concise solutions to common problems. In this example, we find shared
likes and dislikes among our programming team using sets:

[source,clojure]
----
(def Alice {:loves #{:clojure :lisp :scheme} :hates #{:fortran :c :c++}})
(def Bob   {:loves #{:clojure :scheme} :hates #{:c :c++ :algol}})
(def Ted   {:loves #{:clojure :lisp :scheme} :hates #{:algol :basic :c :c++ :fortran}})

(merge-with clojure.set/intersection Alice Bob Ted)
;; -> {:loves #{:scheme :clojure}, :hates #{:c :c++}}
----

Suppose we have a collection of recent scores for our bowling team.
Each game is represented by a map of scores, keyed by bowler. We can
use +merge-with+ to create a single map which records all scores
earned by all bowlers:

[source,clojure]
----
(def scores [{:bob 240 :ted 200 :carol 280 :alice 130}
             {:don 200 :ted 180 :carol 240 :alice 100}
             {:bob 200 :ted 180 :carol 240 :alice 100}
             {:bob 200 :ted 180 :carol 240 :mary 100 :don 144}])

(apply merge-with (comp flatten vector) scores)
;; -> {:don (200 144), :ted (200 180 180 180), :bob (240 200 200),
;;     :carol (280 240 240 240), :mary 100, :alice (130 100 100)}
----

You can even merge nested maps by recursively merging duplicate keys.

[source,clojure]
----
(defn deep-merge
  [& maps]
  (apply merge-with deep-merge maps))
----

===== Discussion

Both +merge+ and +merge-with+ combine their argument maps from left to
right, returning a new immutable map as a result. In the simple case
of +merge+ the rightmost map "wins" for any shared keys.

+merge-with+ facilitates powerful recipes for map combination by
taking an additional function argument. You can imagine +merge-with+
as +reduce+ for maps with common keys. The supplied merging function
must take two arguments, and is called with the values for each pair
of duplicate keys as the result map is computed. Mappings for unique
keys remain as-is in the result.

Here's an example on how to efficiently merge long vectors of hashes
using higher order functions and reducers.

[source,clojure]
----
;; test data generator

(defn make-keyword [s n]
  (keyword (str s n)))

(defn key-index [k]
  (-> k str (subs 2) Long.))

(defn compare-key-index [k1 k2]
  (compare (key-index k1) (key-index k2)))

(defn rand-pairs
  ([]  (rand-pairs 4))
  ([j] (rand-pairs j j))
  ([j k]
   (cons [(make-keyword "s" (rand-int j)) (rand-int k)]
         (lazy-seq (rand-pairs j k)))))

(defn sorted-rand-hash
  ([] (sorted-rand-hash 4))
  ([i] (sorted-rand-hash i i))
  ([i j] (sorted-rand-hash i j j))
  ([i j k]
   (into (sorted-map-by compare-key-index) (take i (rand-pairs j k)))))

(defn sorted-rand-hash-seq
  ([]  (sorted-rand-hash-seq 4))
  ([n] (sorted-rand-hash-seq n n))
  ([n i] (sorted-rand-hash-seq n i i))
  ([n i j] (sorted-rand-hash-seq n i j j))
  ([n i j k]
   (for [_ (range n)] (sorted-rand-hash i j k))))

(defn sorted-rand-hash-vec [& args]
  (into [] (apply sorted-rand-hash-seq args)))


;; hof merging

(defn merge-mk [fn-merge fn-agg fn-elt agg e]
  (if (coll? agg)
      (fn-merge agg (fn-elt e))
      (fn-merge (fn-agg (fn-elt agg)) (fn-elt e))))

(defn merge-sum [agg e]
  (merge-mk + identity identity agg e))

(defn merge-vec [agg e]
  (merge-mk conj vector identity agg e))

(defn val-cnt-map [e]
  (if (map? e) e (sorted-map e 1)))

(defn merge-val-cnt-map [agg e]
  (merge-mk (partial merge-with +) identity val-cnt-map agg e))


;; merge short vector of hashes

(def hv (sorted-rand-hash-vec 8))

(pprint hv)
(pprint (apply merge-with merge-vec hv))
(pprint (apply merge-with merge-val-cnt-map hv))
(pprint (apply merge-with merge-sum hv))


;; reducers library

(require '(clojure.core [reducers :as r]))

(def mon-merge-sum
  (r/monoid (partial merge-with merge-sum)
            #(sorted-map-by compare-key-index)))

(def mon-merge-val-cnt-map
  (r/monoid (partial merge-with merge-val-cnt-map)
            #(sorted-map-by compare-key-index)))


;; fold long vector of hashes

(def lhv (sorted-rand-hash-vec 100000 8 8 8))

(pprint (apply merge-with merge-sum lhv))
(pprint (r/fold mon-merge-sum lhv))

(pprint (apply merge-with merge-val-cnt-map lhv))
(pprint (r/fold mon-merge-val-cnt-map lhv))


;; benchmarks

(require '[criterium.core :as c])

(c/with-progress-reporting
  (c/quick-bench (apply merge-with merge-sum lhv) :verbose))

(c/with-progress-reporting
  (c/quick-bench (r/fold mon-merge-sum lhv) :verbose))


(c/with-progress-reporting
  (c/quick-bench (apply merge-with merge-val-cnt-map lhv) :verbose))

(c/with-progress-reporting
  (c/quick-bench (r/fold mon-merge-val-cnt-map lhv) :verbose))

----

===== See also

* See <<sec_composite_data_maps_setting_keys>> to learn more about manipulating maps.
* See <<sec_composite_data_maps_multiple_values>> for information on
  creating multiple value maps using a Clojure protocol.
