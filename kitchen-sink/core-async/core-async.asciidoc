=== Decoupling Consumers and Producers with +core.async+
[role="byline"]
by Daemian Mack

==== Problem

You want to decouple your program's consumers and producers. 

Introducing explicit queues between components allows them to
communicate asynchronously, makes them simpler to manage independently
and frees up computational resources.

Imagine you are building a custom dashboard that fetches
Twitter messages. These messages are pushed to web browsers over
Server Sent Events (SSE) to provide a real-time display.

Additionally persisting each message to a database
allows displaying a backlog of messages when the web page is initially
loaded.

Thus, the message producer needs to feed two consumers.

The following passage illustrates a synchronous approach.

[source,clojure]
----
(defn database-consumer
  "Accept messages and persist them to a database."
  [msg]
  (println (format "database-consumer received message %s" msg)))

(defn sse-consumer
  "Accept messages and pass them to web browsers via SSE."
  [msg]
  (println (format "sse-consumer received message %s" msg)))

(defn messages
  "Fetch messages from Twitter."
  []
  (range 4))

(defn message-producer
  "Produce messages and deliver them to consumers."
  [& consumers]
  (doseq [msg (messages)
          consumer consumers]
    (consumer msg)))

(message-producer database-consumer sse-consumer)
----

Each message received is sent to each of the consumers passed to
+message-producer+.

This approach is rigid. It offers minimal control over consumer
latency or availability. What if the database needs to buffer incoming
messages? What if you want to temporarily turn off one or more of the
consumers during debugging or partial maintenance downtime?

+core.async+ can help.


==== Solution

Use the https://github.com/clojure/core.async[+core.async+]
library to introduce and coordinate asynchronous channels.

// TODO: Update lib to latest stable.
Before starting, add +[org.clojure/core.async "0.1.242.0-44b1e3-alpha"]+ to your project's
dependencies or start a REPL using lein-try:

[source,shell]
----
$ lein try org.clojure/core.async
----

Here's a version of the above using +core.async+.

[source,clojure]
----
(require '[clojure.core.async :refer [chan sliding-buffer go go-loop timeout >! <!]])

(defn database-consumer
  "Accept messages and persist them to a database."
  []
  (let [in (chan (sliding-buffer 64))]
    (go-loop [data (<! in)]
             (when data
               (println (format "database-consumer received data %s" data))
               (recur (<! in))))
    in))

(defn sse-consumer
  "Accept messages and pass them to web browsers via SSE."
  []
  (let [in (chan (sliding-buffer 64))]
    (go-loop [data (<! in)]
             (when data
               (println (format "sse-consumer received data %s" data))
               (recur (<! in))))
    in))

(defn messages
  "Fetch messages from Twitter."
  []
  (range 4))

(defn producer
  "Produce messages and deliver them to consumers."
  [& channels]
  (go
   (doseq [item items
           out  channels]
     (<! (timeout 2000))
     (>! out item))))

(producer (consumer-a) (consumer-b))
;; => consumer-a received data :a
;; => consumer-b received data :a
;; => consumer-a received data :b
;; => consumer-b received data :b
;; => consumer-a received data :c
;; => consumer-b received data :c
----

Note that each consumer, now a function, needs to be evaluated to return the channel passed in to +producer+.


==== Discussion

One of the benefits of +core.async+ is that it lets you write
callback-style code in a straight-forward manner.

Let's take a closer look at how the code changed above.

[source,clojure]
----
(defn database-consumer
  "Accept messages and persist them to a database."
  []
  (let [in (chan (sliding-buffer 64))] <1>
    (go-loop [data (<! in)] <2>
             (when data <3>
               (println (format "database-consumer received data %s" data))
               (recur (<! in)))) <4>
    in))
----

<1> Here the channel is given a buffer of size 64. The
    +sliding-buffer+ variant dictates that, if this channel
    accumulates more than 64 unread values, older values will start
    "falling off" the end, trading off historical completeness in
    favor of recency. Using +dropping-buffer+ instead would optimize
    in the opposite direction.

<2> +go-loop+ is the core.async response to looping via a construct
    like +while true+. This +go-loop+ takes as its initial value the
    first value read from the channel via +<!+.

<3> If that value is non-+nil+ -- that is, if the channel has been
    written to but not yet closed -- the value is then printed.

<4> The loop +recur+s with the next value read from the channel bound
    to the var +data+.

Because the +go-loop+ block is asynchronous, the read call parks until
a value is placed on the channel. The remainder of the +go-loop+ block
-- here, the +println+ call -- is pending. Since the channel is
returned as the +database-consumer+ function's value, other parts of
the system -- namely, the producer -- are free to write to the channel
while the read parks. The first value written to the channel will
satisfy that read call, allowing the rest of the +go-loop+ block to then
make use of whatever value is written.

This consumer is now asynchronous, grants some control over its
latency, and will read values until the channel closes.


[source,clojure]
----
(defn producer
  [& channels]
  (go
   (doseq [item (items)
           out  channels] <1>
     (<! (timeout 2000)) <2>
     (>! out item)))) <3>
----

In a similar vein, this producer will...

<1> For each item-channel pair,

<2> read from a +timeout+ channel to cause a 2-second pause for effect, and

<3> use +>!+ to place the item onto the channel.

Although the operations are asynchronous, they still occur serially.
Using unbuffered consumer channels would mean if one of the consumers
takes from the channel too slowly, the pipeline will stall; the
producer will not be able to put further values onto the channels.

+core.async+ has more advanced facilities like pub-sub, mixes and taps
that provide further coordination of channel behavior. For more
details, visit the http://clojure.github.io/core.async/[+core.async+ overview].
