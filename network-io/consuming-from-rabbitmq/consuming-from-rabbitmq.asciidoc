=== Consuming from RabbitMQ
// By Michael Klishin (michaelklishin)

===== Problem

You want to communicate with other applications over http://rabbitmq.com[RabbitMQ]
and need to consume messages from Clojure.

===== Solution

Use http://clojurerabbitmq.info[Langohr], a small feature complete RabbitMQ client, to communicate
with RabbitMQ.

In order to successfully go through this recipe, you should have
RabbitMQ installed. You can find details on how to install RabbitMQ
here: http://www.rabbitmq.com/download.html.

Include Langohr into your project file:

.project.clj
[source,clojure]
----
(defproject langohr-example "1.0.0-SNAPSHOT"
              :dependencies [[com.novemberain/langohr "1.4.1"]])
----

Next, make sure that RabbitMQ is running and connect to it.

[source,clojure]
----
(ns langohr.example
  (:require [langohr.core :as rmq]))

;; Will connect to a RabbitMQ cluster node on localhost:5672
(let [conn (rmq/connect {:hostname "localhost"})]
  (comment ...))
----

AMQP 0-9-1 is a multi-channeled protocol. It multiplexes several
lightweight channels over a single TCP connection. Next, lets
open a channel we can use to consume messages:

[source,clojure]
----
(ns langohr.example
  (:require [langohr.core    :as rmq]
            [langohr.channel :as lch]))

;; Connect and open a channel that will be used to interact
;; with RabbitMQ
(let [conn (rmq/connect {:hostname "localhost"})
      ch   (lch/open conn)]
  (comment ...))
----

Having a channel open, you can declare or use existing queues.
Queues have names that can either be given by clients or
generated by RabbitMQ.

To create a queue with a provided name,
use *langohr.queue/declare*:

[source,clojure]
----
(ns langohr.example
  (:require [langohr.core     :as rmq]
            [langohr.channel  :as lch]
            [langohr.basic    :as lb]
            [langohr.queue    :as lq]))

(let [conn (rmq/connect {:hostname "localhost"})
      ch   (lch/open conn)
      q    "tasks.imaging.resize"]
  (lq/declare ch q)
  (comment ...))
----

To create a queue with server-generated name,
use *langohr.queue/declare-server-named*:

[source,clojure]
----
(ns langohr.example
  (:require [langohr.core     :as rmq]
            [langohr.channel  :as lch]
            [langohr.basic    :as lb]
            [langohr.queue    :as lq]))

(let [conn (rmq/connect {:hostname "localhost"})
      ch   (lch/open conn)
      q    (lq/declare-server-named ch)]
  (comment ...))
----

*langohr.queue/declare* takes extra options that
control queue properties, e.g. if it's durable:

[source,clojure]
----
(ns langohr.example
  (:require [langohr.core     :as rmq]
            [langohr.channel  :as lch]
            [langohr.basic    :as lb]
            [langohr.queue    :as lq]))

(let [conn (rmq/connect {:hostname "localhost"})
      ch   (lch/open conn)
      q    "tasks.imaging.resize"]
  (lq/declare ch q :durable true :auto-delete false)
  (comment ...))
----

Having a queue declared, you can consume messages in
two ways:

 * Fetch them on demand ("pull API") using *langohr.basic/get*
 * Register a consumer (subscription) with *langohr.consumers/subscribe* ("push API")

First, an example of the former:

[source,clojure]
----
(ns langohr.example
  (:require [langohr.core     :as rmq]
            [langohr.channel  :as lch]
            [langohr.basic    :as lb]
            [langohr.queue    :as lq]))

(let [conn (rmq/connect {:hostname "localhost"})
      ch   (lch/open conn)
      q    "tasks.imaging.resize"]
  (lq/declare ch q :durable true :auto-delete false)
  (println (lb/get ch q)))
----

If there are no messages in the queue, the function will return
nil.

[source,clojure]
----
(ns langohr.example
  (:require [langohr.core     :as rmq]
            [langohr.channel  :as lch]
            [langohr.basic    :as lb]
            [langohr.queue    :as lq]))

(defn delivery-handler
  "Handles messages pushed by RabbitMQ"
  [ch metadata ^bytes payload]
  (println (format "Received %s" (String. payload "UTF-8"))))

(let [conn (rmq/connect {:hostname "localhost"})
      ch   (lch/open conn)
      q    "tasks.imaging.resize"]
  (lq/declare ch q :durable true :auto-delete false)
  (lb/subscribe ch q delivery-handler))
----

*langohr.basic/subscribe* also takes callbacks for various
events, e.g. when the consumer is cancelled:

[source,clojure]
----
(ns langohr.example
  (:require [langohr.core     :as rmq]
            [langohr.channel  :as lch]
            [langohr.basic    :as lb]
            [langohr.queue    :as lq]))

(defn delivery-handler
  "Handles messages pushed by RabbitMQ"
  [ch metadata ^bytes payload]
  (println (format "Received %s" (String. payload "UTF-8"))))

(let [conn (rmq/connect {:hostname "localhost"})
      ch   (lch/open conn)
      q    "tasks.imaging.resize"]
  (lq/declare ch q :durable true :auto-delete false)
  (lb/subscribe ch q delivery-handler :handle-cancel-fn (fn [consumer-tag]
                                                                                (comment ...))))
----

*langohr.consumers/subscribe* will not block the calling thread. If that'd
be more convenient in your case, there is a version that does that,
*langohr.consumers/blocking-subscribe*.


===== Discussion

So far we have demonstrated just enough functionality to consume messages
from a queue. Consumed messages need to be acknowledged. That can happen
automatically (RabbitMQ will consider a message acknowledged as soon
as it sends it to a consumer) or manually.

When a message is acknowledged, it is removed from the queue. If a channel
closes unexpectedly before a delivery is acknowledged, it will be automatically
requeued by RabbitMQ.

Note that these acknowledgements have application-specific semantics
and help ensure that messages are processed, not just data delivery
(what TCP acknowledgements are concerned with).

To enable manual acknowledgements, pass *:auto-ack false* to *langohr.consumers/subscribe*:

[source,clojure]
----
(ns langohr.example
  (:require [langohr.core     :as rmq]
            [langohr.channel  :as lch]
            [langohr.basic    :as lb]
            [langohr.queue    :as lq]))

(defn delivery-handler
  "Handles messages pushed by RabbitMQ"
  [ch metadata ^bytes payload]
  (println (format "Received %s" (String. payload "UTF-8"))))

(let [conn (rmq/connect {:hostname "localhost"})
      ch   (lch/open conn)
      q    "tasks.imaging.resize"]
  (lq/declare ch q :durable true :auto-delete false)
  (lb/subscribe ch q delivery-handler :auto-ack false))
----

With manual acknowledgement, it is application's responsibility to
either acknowledge or reject a delivery. This is done with
*langohr.basic/ack* and *langohr.basic/nack*, respectively,
which takes a delivery attribute called *delivery-tag* (delivery ID):

[source,clojure]
----
(ns langohr.example
  (:require [langohr.core     :as rmq]
            [langohr.channel  :as lch]
            [langohr.basic    :as lb]
            [langohr.queue    :as lq]))

(defn delivery-handler
  "Handles messages pushed by RabbitMQ"
  [ch {:keys [delivery-tag] :as metadata} ^bytes payload]
  (println (format "Received %s" (String. payload "UTF-8")))
  ;; acknowledge the delivery
  (lb/ack ch delivery-tag))

(let [conn (rmq/connect {:hostname "localhost"})
      ch   (lch/open conn)
      q    "tasks.imaging.resize"]
  (lq/declare ch q :durable true :auto-delete false)
  (lb/subscribe ch q delivery-handler :auto-ack false))
----

An example that rejects a message and re-queues it:

[source,clojure]
----
(ns langohr.example
  (:require [langohr.core     :as rmq]
            [langohr.channel  :as lch]
            [langohr.basic    :as lb]
            [langohr.queue    :as lq]))

(defn delivery-handler
  "Handles messages pushed by RabbitMQ"
  [ch {:keys [delivery-tag] :as metadata} ^bytes payload]
  (println (format "Received %s" (String. payload "UTF-8")))
  ;; requeue a single message
  (lb/nack ch delivery-tag false true))

(let [conn (rmq/connect {:hostname "localhost"})
      ch   (lch/open conn)
      q    "tasks.imaging.resize"]
  (lq/declare ch q :durable true :auto-delete false)
  (lb/subscribe ch q delivery-handler :auto-ack false))
----

Note that if you requeue a message with just one consumer on it,
it will be redelivered immediately.

It is possible to control how many messages will be pushed to
the client before receiving an ack for at least one of them.
This is known as the *prefetch setting* and is set using
*langohr.basic/qos*:

[source,clojure]
----
(ns langohr.example
  (:require [langohr.core     :as rmq]
            [langohr.channel  :as lch]
            [langohr.basic    :as lb]
            [langohr.queue    :as lq]))

(defn delivery-handler
  "Handles messages pushed by RabbitMQ"
  [ch {:keys [delivery-tag] :as metadata} ^bytes payload]
  (println (format "Received %s" (String. payload "UTF-8")))
  ;; acknowledge the delivery
  (lb/ack ch delivery-tag))

(let [conn (rmq/connect {:hostname "localhost"})
      ch   (lch/open conn)
      q    "tasks.imaging.resize"]
  (lq/declare ch q :durable true :auto-delete false)
  (lb/subscribe ch q delivery-handler :auto-ack false))
----

An example that rejects a message and re-queues it:

[source,clojure]
----
(ns langohr.example
  (:require [langohr.core     :as rmq]
            [langohr.channel  :as lch]
            [langohr.basic    :as lb]
            [langohr.queue    :as lq]))

(let [conn (rmq/connect {:hostname "localhost"})
      ch   (lch/open conn)
      q    "tasks.imaging.resize"]
  ;; RabbitMQ will deliver consumers on this channel up to
  ;; 128 messages before it will wait an acknowledgement
  ;; for at least one of them
  (lb/qos ch 128)
  (comment ...))
----

RabbitMQ queues can also be mirrored between
cluster nodes for high availability, have bounded
length or expiration period for messages, and more.
To learn more, see RabbitMQ and Langohr documentation
sites.

Key functions related to working with
queues and consumers can be found in *langohr.queue*,
*langohr.consumers*, and *langohr.basic* namespaces.

Langohr is a feature complete RabbitMQ client that supports
AMQP 0-9-1, RabbitMQ extensions to it and provides HTTP
API client.

===== See Also
See http://clojurerabbitmq.info[Langohr documentation] and
http://rabbitmq.com/getstarted.html[RabbitMQ tutorials] to learn more.

Langohr http://reference.clojurerabbitmq.info[API reference] is also
available.
