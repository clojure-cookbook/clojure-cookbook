[[sec_db_manipulating_a_sql_database]]
=== Manipulating an SQL Database
[role="byline"]
by Tom Hicks
// Made after documentation by Sean Corfield and Stephen Gilardi.

==== Problem

You want your Clojure program to manipulate tables and records in an SQL database.(((SQL databases, manipulation of)))((("Clojure", "clojure.java.jbdc library")))(((Java, Java JDBC)))(((PostgreSQL database)))

==== Solution

Use the +clojure.java.jdbc+ library for JDBC-based access to SQL databases.

To follow along with this recipe, you'll need a running SQL database
and an existing table to connect to. We suggest PostgreSQL.footnote:[Mac
users: visit http://postgresapp.com/ to download an
easy-to-install DMG. Everyone else: you'll find a guide for your operating
system on the
http://bit.ly/postgres-install[PostgreSQL
wiki].]

After you have PostgreSQL running (presumably on _localhost:5432_), run the following
command to create a database for this recipe:

[source,text]
----
# On Mac:
$ /Applications/Postgres93.app/Contents/MacOS/bin/createdb cookbook_experiments

# Everyone else:
$ createdb cookbook_experiments
----

Before starting, add `[org.clojure/java.jdbc "0.3.0"]` and
`[java-jdbc/dsl "0.1.0"]` to your project's dependencies. You'll also
need a JDBC driver for the RDBMS of your choice. If you're following
along with this sample, use `[org.postgresql/postgresql
"9.2-1003-jdbc4"]`. To start a REPL using +lein-try+, enter the
following Leiningen command:

[source,text]
----
$ lein try org.clojure/java.jdbc "0.3.0" \
           java-jdbc/dsl "0.1.0" \
           org.postgresql/postgresql "9.2-1003-jdbc4"
----

Then, define how the database should be accessed:

[source,clojure]
----
(def db-spec {:classname "org.postgresql.Driver"
              :subprotocol "postgresql"
              :subname "//localhost:5432/cookbook_experiments"})
----

To create a new table, use the +java-jdbc.ddl/create-table+
function to generate the necessary DDL statement, and then pass the
statement to the +jdbc/db-do-commands+ function to execute it:

[source,clojure]
----
(require '[clojure.java.jdbc :as jdbc]
         '[java-jdbc.ddl :as ddl])

(jdbc/db-do-commands db-spec
  (ddl/create-table :fruit
    [:name "varchar(16)" "PRIMARY KEY"]
    [:appearance "varchar(32)"]
    [:cost :int "NOT NULL"]
    [:unit "varchar(16)"]
    [:grade :real]))
;; -> (0)
----

Insert complete records into a table using the
+clojure.java.jdbc/insert!+ function, invoking it with a vector of the
column values for each row. Be sure to provide the column values in
the order in which the columns were declared in the table:

[source,clojure]
----
(jdbc/insert! db-spec :fruit
  nil ; column names omitted
  ["Red Delicious" "dark red" 20 "bushel" 8.2]
  ["Plantain" "mild spotting" 48 "stalk" 7.4]
  ["Kiwifruit" "fresh"  35 "crate" 9.1]
  ["Plum" "ripe" 12 "carton" 8.4])
;; -> (1 1 1 1)
----

To query the database, generate the SQL for the query with the
+java-jdbc.sql/select+ function, then invoke +clojure.java.jdbc/query+
with the result:

[source,clojure]
----
(require '[java-jdbc.sql :as sql])

(jdbc/query db-spec
  (sql/select * :fruit (sql/where {:appearance "ripe"})))
;; -> ({:grade 8.4, :unit "carton", :cost 12, :appearance "ripe", :name "Plum"})
----

If you no longer need a particular table, invoke
+clojure.java.dbc/jdb-do-commands+ with the appropriate DDL statements
generated by +java-jdbc.ddl/drop-table+:

[source,clojure]
----
(jdbc/db-do-commands db-spec
  (ddl/create-table :delete_me
    [:name "varchar(16)" "PRIMARY KEY"]))

(jdbc/db-do-commands db-spec (ddl/drop-table :delete_me))
;; -> (0)
----

==== Discussion

The +clojure.java.jdbc+ library provides functions that wrap the
basic capabilities of the Java JDBC specification. The +java-jdbc/dsl+ project's  +java-jdbc.sql+
and +java-jdbc.ddl+ namespaces implement small DSLs to generate basic
SQL DML and DDL statements.

[NOTE]
====
+java-jdbc/dsl+ used to be a part of +clojure.java.jdbc+, but was
removed to keep the API of the core library as small as possible.
====

The +java-dbc.ddl/create-table+ function generates the DDL
needed to create a table. The arguments are a table name and a vector
for each column specification. At the time of this writing,
table-level specifications are not yet supported.(((tables, creating)))

===== Inserting and updating records

Records may be inserted into a table in a variety of ways. In addition
to the vector method illustrated, the(((tables, inserting/updating records)))(((records, inserting/updating)))
+clojure.java.jdbc/insert!+ function can accept one or more maps with
column names as keys:

[source,clojure]
----
(jdbc/insert! db-spec :fruit
  {:name "Banana" :appearance "spotting" :cost 35}
  {:name "Tomato" :appearance "rotten" :cost 10 :grade 1.4}
  {:name "Peach" :appearance "fresh" :cost 37 :unit "pallet"})
;; -> ({:grade nil, :unit nil, :cost 35, :appearance "spotting", :name "Banana"}
;;     {:grade 1.4, :unit nil, :cost 10, :appearance "rotten", :name "Tomato"}
;;     {:grade nil, :unit "pallet", :cost 37, :appearance "fresh", 
;;      :name "Peach"})
----

If you want to insert rows but only specify some columns' values, you
can invoke +clojure.java.jdbc/insert!+ with a vector of column
names followed by one or more vectors containing values for those
columns:

[source,clojure]
----
(jdbc/insert! db-spec :fruit
  [:name :cost]
  ["Mango" 84]
  ["Kumquat" 77])
;; -> (1 1)
----

To update existing records, invoke +clojure.java.jdbc/update!+ with a
map of column names to new values. The optional(((records, updating)))
+java-jdbc.sql/where+ clause controls which rows will be
updated:

[source,clojure]
----
(jdbc/update! db-spec :fruit
  {:grade 7.0 :appearance "spotting" :cost 75}
  (sql/where {:name "Mango"}))
;; -> (1)
----

===== Transactions

Database transactions are available to ensure that multiple operations
are performed atomically (i.e., all or none). The(((transaction-aware connections)))(((macros, clojure.java.jdbc/with-db-transaction)))((("Clojure", "clojure.java.jdbc/with-db-transaction macro")))
+clojure.java.jdbc/with-db-transaction+ macro creates a transaction-aware
connection from the database specification. Use the transaction-aware
connection for the duration of the transaction:

[source,clojure]
----
;; Insert two new fruits atomically
(jdbc/with-db-transaction [trans-conn db-spec]
  (jdbc/insert! trans-conn :fruit {:name "Fig" :cost 12})
  (jdbc/insert! trans-conn :fruit {:name "Date" :cost 14}))
;; -> ({:grade nil, :unit nil, :cost 14, :appearance nil, :name "Date"})
----

If an exception is thrown, the transaction is rolled back:

[source,clojure]
----
;; Query how many items the table has now
(defn fruit-count
  "Query how many items are in the fruit table." 
  [db-spec]
  (let [result (jdbc/query db-spec (sql/select "count(*)" :fruit))]
    (:count (first result))))

(fruit-count db-spec)
;; -> 11

(jdbc/with-db-transaction [trans-conn db-spec]
  (jdbc/insert! trans-conn :fruit
    [:name :cost]
    ["Grape" 86]
    ["Pear" 86])
  ;; At this point the insert! call is complete, but the transaction
  ;; is not. An exception will cause the transaction to roll back,
  ;; leaving the database unchanged.
  (throw (Exception. "sql-test-exception")))
;; -> Exception sql-test-exception ...

;; The table still has the same number of items
(fruit-count db-spec)
;; -> 11
----

Transactions can be explicitly set to roll back with the
+clojure.java.jdbc/db-set-rollback-only!+ function. This setting can
be unset with the +clojure.java.jdbc/db-unset-rollback-only!+
function and tested with the +clojure.java.jdbc/is-rollback-only+
function:

[source,clojure]
----
(fruit-count db-spec)
;; -> 11

(jdbc/with-db-transaction [trans-conn db-spec]
  (jdbc/db-set-rollback-only! trans-conn)
  (jdbc/insert! trans-conn :fruit {:name "Pear" :cost 69}))
;; -> ({:grade nil, :unit nil, :cost 69, :appearance nil, :name "Pear"})

;; The table still has the same number of items
(fruit-count db-spec)
;; -> 11
----

===== Reading and processing records

Database records are returned from queries as Clojure maps, with the
table's column names used as keys. Retrieval of a set of database(((records, reading/processing)))
records produces a sequence of maps that can then be processed with
all the normal Clojure functions. Here, we query all the records in
the fruit table, gathering the name and grade of any low-quality fruit:

[source,clojure]
----
(->> (jdbc/query db-spec (sql/select "name, grade" :fruit))
     ;; Filter all fruits by fruits with grade < 3.0
     (filter (fn [{:keys [grade]}] (and grade (< grade 3.0))))
     (map (juxt :name :grade)))
;; -> (["Tomato" 1.4])
----

The preceding example uses the SQL DSL provided by the
+java-jdbc.sql+ namespace. The DSL implements a simple
abstraction over the generation of SQL statements. At present, it
provides some basic mechanisms for selects, joins, +where+ clauses, and
+order-by+ clauses:

[source,clojure]
----
(defn fresh-fruit []
  (jdbc/query db-spec
    (sql/select [:f.name] {:fruit :f}
      (sql/where {:f.appearance "fresh"})
      (sql/order-by :f.name))))

(fresh-fruit)
;; -> ({:name "Kiwifruit"} {:name "Peach"})
----

The use of the SQL DSL is entirely optional. For more direct control,
a vector containing an SQL query string and arguments can be passed to
the +query+ function. The following function also finds low-quality
fruit but does it by passing a quality threshold value directly to
the SQL statement:

[source,clojure]
----
(defn find-low-quality [acceptable]
  (jdbc/query db-spec
              ["select name, grade from fruit where grade < ?" acceptable]))

(find-low-quality 3.0)
;; -> ({:grade 1.4, :name "Tomato"})
----

The +jdbc/query+ function has several optional keyword parameters that control
how it constructs the returned result set. The +:result-set-fn+ parameter
specifies a function that is applied to the entire result set (a lazy
sequence) before it is returned. The default argument is the +doall+ function:

[source,clojure]
----
(defn hi-lo [rs] [(first rs) (last rs)])

;; Find the highest- and lowest-cost fruits
(jdbc/query db-spec
            ["select * from fruit order by cost desc"]
            :result-set-fn hi-lo)
;; -> [{:grade nil, :unit nil, :cost 77, :appearance nil, :name "Kumquat"}
;;     {:grade 1.4, :unit nil, :cost 10, :appearance "rotten", :name "Tomato"}]
----

The +:row-fn+ parameter specifies a function that is applied to each
result row as the result is constructed. The default argument is the
+identity+ function:

[source,clojure]
----
(defn add-tax [row] (assoc row :tax (* 0.08 (row :cost))))

(jdbc/query db-spec
             ["select name,cost from fruit where cost = 12"] 
             :row-fn add-tax)
;; -> ({:tax 0.96, :cost 12, :name "Plum"} {:tax 0.96, :cost 12, :name "Fig"})
----

The Boolean +:as-arrays?+ parameter indicates whether to return the
results as a set of vectors or not. The default argument value is
+false+:

[source,clojure]
----
(jdbc/query db-spec
            ["select name,cost,grade from fruit where appearance = 'spotting'"]
            :as-arrays? true)
;; -> ([:name :cost :grade] ["Banana" 35 nil] ["Mango" 75 7.0])
----

Finally, the +:identifiers+ parameter takes a function that is
applied to each column name in the result set. The default argument is
the +clojure.string/lower-case+ function, which lowercases the table's
column names before they are converted to keywords. If your
application needs to perform some different conversion of column
names, provide an alternate function using this keyword parameter.

The +clojure.java.jdbc+ library is a good choice for quick and easy
access to most popular relational databases. Its use of Clojure's
vectors and maps to represent records blends well with Clojure's
emphasis on data-oriented programming. Novice users of SQL can
conveniently utilize the provided DSLs while expert users can more
directly construct and execute complex SQL statements.

==== See Also

* See <<sec_db_connecting_to_a_sql_database>>, to learn about basic
  database connections with +clojure.java.jdbc+.
* See <<sec_db_connecting_with_a_connection_pooling>>, to learn about
  pooling connections to an SQL database with BoneCP and
  +clojure.java.jdbc+.
* Visit the +clojure.java.jdbc+
  https://github.com/clojure/java.jdbc[GitHub repository] for more
  detailed information on the library.
* Visit the +java-jdbc/dsl+
  https://github.com/seancorfield/jsql[GitHub repository] for more
  information on the SQL query generation capabilities it provides.
  Alternatively, investigate the https://github.com/jkk/honeysql[Honey
  SQL], https://github.com/r0man/sqlingvo[SQLingvo], or
  http://sqlkorma.com/[Korma] libraries for SQL query generation.
  Korma is covered in <<sec_sql_korma>>.
